---
title: std::vector
---

import DeclarationTable from '@components/mdx/DeclarationTable.astro';
import StdVer from '@components/mdx/StdVer.astro';
import ComponentPreview from '@components/mdx/ComponentPreview.astro';
import ParameterTable from '@components/mdx/ParameterTable.astro';
import ParameterRow from '@components/mdx/ParameterRow.astro';
import MemberTable from '@components/mdx/MemberTable.astro';
import MemberRow from '@components/mdx/MemberRow.astro';
import MemberTypeTable from '@components/mdx/MemberTypeTable.astro';
import MemberTypeRow from '@components/mdx/MemberTypeRow.astro';
import StdVerTable from '@components/mdx/StdVerTable.astro';
import StdVerRow from '@components/mdx/StdVerRow.astro';
import FeatureTable from '@components/mdx/FeatureTable.astro';

<DeclarationTable header="vector" content={`(1) 
template<
    class T, 
    class Allocator = std::allocator<T>
> class vector;

(2)	(since C++17) namespace pmr { 
    template< class T > 
    using vector = std::vector<T, std::pmr::polymorphic_allocator<T>>; 
}`}/>

1) `std::vector` is a sequence container that encapsulates dynamic size arrays.
2) `std::pmr::vector` is an alias template that uses a polymorphic allocator.
Except for the `std::vector<bool>` partial specialization, the elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.

The storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].

Reallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.

The complexity (efficiency) of common operations on vectors is as follows:

- Random access - constant ùìû(1).
- Insertion or removal of elements at the end - amortized constant ùìû(1).
- Insertion or removal of elements - linear in the distance to the end of the vector ùìû(n).

`std::vector` (for T other than `bool`) meets the requirements of `Container`<StdVer since="11" inline>, `AllocatorAwareContainer`</StdVer>, `SequenceContainer`<StdVer since="17" inline>, `ContiguousContainer`</StdVer> and `ReversibleContainer`.

<StdVer since="20">
All member functions of std::vector are constexpr: it is possible to create and use std::vector objects in the evaluation of a constant expression.
However, std::vector objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.
</StdVer>

‚Üë In libstdc++, `shrink_to_fit()` is not available in C++98 mode.

## Template parameters

<ParameterTable>
    <ParameterRow paramName="T">
        The type of the elements. 
        <StdVerTable>
            <StdVerRow until="11">
            T must meet the requirements of CopyAssignable and CopyConstructible.
            </StdVerRow>
            <StdVerRow since="11" until="17">
            The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of Erasable, but many member functions impose stricter requirements.
            </StdVerRow>
            <StdVerRow since="17">
            The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements.        
            <FeatureTable>
            |__cpp_lib_incomplete_container_elements|201505L|C++17|Minimal incomplete type support|
            </FeatureTable>
            </StdVerRow>
        </StdVerTable>
    </ParameterRow>
    <ParameterRow paramName="Allocator">
        An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of `Allocator`. The behavior is undefined(until C++20)The program is ill-formed(since C++20) if Allocator::value_type is not the same as `T`.
    </ParameterRow>
</ParameterTable>

## Specializations

The standard library provides a specialization of std::vector for the type bool, which may be optimized for space efficiency.

<MemberTable>
  <MemberRow names={[{name:"<b>vector</b>&lt;bool&gt;", href:"/cpp/container/vector_bool"}]} category="class template specialization">
    space-efficient dynamic bitset
  </MemberRow>
</MemberTable>

## Iterator invalidation

|Operations|Invalidated|
|-|-|
|All read only operations|Never.|
|swap, std::swap|end()|
|clear, operator=, assign|Always.|
|reserve, shrink_to_fit|If the vector changed capacity, all of them. If not, none.|
|erase|Erased elements and all elements after them (including end()).|
|push_back, emplace_back|If the vector changed capacity, all of them. If not, only end().|
|insert, emplace|If the vector changed capacity, all of them. <br/> If not, only those at or after the insertion point (including end()).|
|resize|If the vector changed capacity, all of them. If not, only end() and any elements erased.|
|pop_back|The element erased and end().|

## Member types

<MemberTypeTable>
  <MemberTypeRow type="value_type">
    `T`
  </MemberTypeRow>
  
  <MemberTypeRow type="allocator_type">
    `Allocator`
  </MemberTypeRow>
  
  <MemberTypeRow type="size_type">
    Unsigned integer type (usually `std::size_t`)
  </MemberTypeRow>
  
  <MemberTypeRow type="difference_type">
    Signed integer type (usually `std::ptrdiff_t`)
  </MemberTypeRow>
  
  <MemberTypeRow type="reference">
    `value_type&`
  </MemberTypeRow>
  
  <MemberTypeRow type="const_reference">
    `const value_type&`
  </MemberTypeRow>
  
  <MemberTypeRow type="pointer">
    <StdVerTable>
      <StdVerRow until="11">`Allocator::pointer`</StdVerRow>
      <StdVerRow since="11">`std::allocator_traits<Allocator>::pointer`</StdVerRow>
    </StdVerTable>
  </MemberTypeRow>
  
  <MemberTypeRow type="const_pointer">
    <StdVerTable>
      <StdVerRow until="11">`Allocator::const_pointer`</StdVerRow>
      <StdVerRow since="11">`std::allocator_traits<Allocator>::const_pointer`</StdVerRow>
    </StdVerTable>
  </MemberTypeRow>
  
  <MemberTypeRow type="iterator">
    <StdVerTable>
      <StdVerRow until="20">
        <div><em>LegacyRandomAccessIterator</em> and <em>LegacyContiguousIterator</em> to `value_type`</div>
      </StdVerRow>
      <StdVerRow since="20">
        <div><em>LegacyRandomAccessIterator</em>, <code>contiguous_iterator</code>, and <em>ConstexprIterator</em> to `value_type`</div>
      </StdVerRow>
    </StdVerTable>
  </MemberTypeRow>
  
  <MemberTypeRow type="const_iterator">
    <StdVerTable>
      <StdVerRow until="20">
        <div><em>LegacyRandomAccessIterator</em> and <em>LegacyContiguousIterator</em> to `const value_type`</div>
      </StdVerRow>
      <StdVerRow since="20">
        <div><em>LegacyRandomAccessIterator</em>, <code>contiguous_iterator</code>, and <em>ConstexprIterator</em> to `const value_type`</div>
      </StdVerRow>
    </StdVerTable>
  </MemberTypeRow>
  
  <MemberTypeRow type="reverse_iterator">
    `std::reverse_iterator<iterator>`
  </MemberTypeRow>
  
  <MemberTypeRow type="const_reverse_iterator">
    `std::reverse_iterator<const_iterator>`
  </MemberTypeRow>
</MemberTypeTable>

## Member functions

<MemberTable>
  <MemberRow names="(constructor)" category="public member function">
    constructs the vector
  </MemberRow>
  
  <MemberRow names="(destructor)" category="public member function">
    destructs the vector
  </MemberRow>
  
  <MemberRow names="operator=" category="public member function">
    assigns values to the container
  </MemberRow>
  
  <MemberRow names="assign" category="public member function">
    assigns values to the container
  </MemberRow>
  
  <MemberRow names={[{name:"assign_range", version:"23"}]} category="public member function">
    assigns a range of values to the container
  </MemberRow>
  
  <MemberRow names="get_allocator" category="public member function">
    returns the associated allocator
  </MemberRow>
</MemberTable>

### Element access

<MemberTable>
  <MemberRow names="at" category="public member function">
    access specified element with bounds checking
  </MemberRow>
  
  <MemberRow names="operator[]" category="public member function">
    access specified element
  </MemberRow>
  
  <MemberRow names="front" category="public member function">
    access the first element
  </MemberRow>
  
  <MemberRow names="back" category="public member function">
    access the last element
  </MemberRow>
  
  <MemberRow names="data" category="public member function">
    direct access to the underlying contiguous storage
  </MemberRow>
</MemberTable>

### Iterators

<MemberTable>
  <MemberRow names={[{name:"begin"}, {name:"cbegin", version:"11"}]} category="public member function">
    returns an iterator to the beginning
  </MemberRow>
  
  <MemberRow names={[{name:"end"}, {name:"cend", version:"11"}]} category="public member function">
    returns an iterator to the end
  </MemberRow>
  
  <MemberRow names={[{name:"rbegin"}, {name:"crbegin", version:"11"}]} category="public member function">
    returns a reverse iterator to the beginning
  </MemberRow>
  
  <MemberRow names={[{name:"rend"}, {name:"crend", version:"11"}]} category="public member function">
    returns a reverse iterator to the end
  </MemberRow>
</MemberTable>

### Capacity

<MemberTable>
  <MemberRow names="empty" category="public member function">
    checks whether the container is empty
  </MemberRow>
  
  <MemberRow names="size" category="public member function">
    returns the number of elements
  </MemberRow>
  
  <MemberRow names="max_size" category="public member function">
    returns the maximum possible number of elements
  </MemberRow>
  
  <MemberRow names="reserve" category="public member function">
    reserves storage
  </MemberRow>
  
  <MemberRow names="capacity" category="public member function">
    returns the number of elements that can be held in currently allocated storage
  </MemberRow>
  
  <MemberRow names={[{name:"shrink_to_fit", version:"11"}]} category="public member function">
    reduces memory usage by freeing unused memory
  </MemberRow>
</MemberTable>

### Modifiers

<MemberTable>
  <MemberRow names="clear" category="public member function">
    clears the contents
  </MemberRow>
  
  <MemberRow names="insert" category="public member function">
    inserts elements
  </MemberRow>
  
  <MemberRow names={[{name:"insert_range", version:"23"}]} category="public member function">
    inserts a range of elements
  </MemberRow>
  
  <MemberRow names={[{name:"emplace", version:"11"}]} category="public member function">
    constructs element in-place
  </MemberRow>
  
  <MemberRow names="erase" category="public member function">
    erases elements
  </MemberRow>
  
  <MemberRow names="push_back" category="public member function">
    adds an element to the end
  </MemberRow>
  
  <MemberRow names={[{name:"emplace_back", version:"11"}]} category="public member function">
    constructs an element in-place at the end
  </MemberRow>
  
  <MemberRow names={[{name:"append_range", version:"23"}]} category="public member function">
    adds a range of elements to the end
  </MemberRow>
  
  <MemberRow names="pop_back" category="public member function">
    removes the last element
  </MemberRow>
  
  <MemberRow names="resize" category="public member function">
    changes the number of elements stored
  </MemberRow>
  
  <MemberRow names="swap" category="public member function">
    swaps the contents
  </MemberRow>
</MemberTable>

## Non-member functions

<MemberTable>
  <MemberRow names={["operator==", {name:"operator!=", removed:"20"}, {name:"operator<", removed:"20"}, {name:"operator<=", removed:"20"}, {name:"operator>", removed:"20"}, {name:"operator>=", removed:"20"}, {name:"operator<=>", version:"20"}]} category="function template">
    lexicographically compares the values of two vectors
  </MemberRow>
  
  <MemberRow names={[{name:"std::swap", version:"11"}]} category="function template">
    specializes the std::swap algorithm
  </MemberRow>
  
  <MemberRow names={[{name:"erase", version:"20"}, {name:"erase_if", version:"20"}]} category="function template">
    erases all elements satisfying specific criteria
  </MemberRow>
</MemberTable>

## Deduction guides


## Notes

<FeatureTable>
|__cpp_lib_containers_ranges|202202L|C++23|Ranges construction and insertion for containers|
|__cpp_lib_ranges_reserve_hint|202502L|C++26|ranges::approximately_sized_range, ranges::reserve_hint, and changes to std::vector|
</FeatureTable>

## Example

```cpp
#include <iostream>
#include <vector>
 
int main()
{
    // Create a vector containing integers
    std::vector<int> v = {8, 4, 5, 9};
 
    // Add two more integers to vector
    v.push_back(6);
    v.push_back(9);
 
    // Overwrite element at position 2
    v[2] = -1;
 
    // Print out the vector
    for (int n : v)
        std::cout << n << ' ';
    std::cout << '\n';
}
```
Output:
```
8 4 -1 9 6 9
```
## Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.

## See also

<MemberTable>
  <MemberRow names={[{name:"inplace_vector", version:"26"}]} category="class template">
    resizable, fixed capacity, inplace contiguous array
  </MemberRow>

  <MemberRow names={[{name:"array", version:"11"}]} category="class template">
    fixed-sized inplace contiguous array
  </MemberRow>

  <MemberRow names={[{name:"deque", version:"11"}]} category="class template">
    double-ended queue
  </MemberRow>
</MemberTable>